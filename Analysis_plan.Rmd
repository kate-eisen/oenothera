---
title: "Analysis plan"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## The structure of the dataset

- We have five populations. In each population, there is a variable number of samples of different plants, and a varying number of samples per plant.

  + *Issue*: We need to decide how to handle these repeated and variable measurements. Is repeatability something we want to directly test for? If so, that would argue for running some kind of analysis to look at the variability within and between plants. If not, we could either cull the dataset to one sample per plant, or we could keep all of the replicates in the dataset, if we can use random effects to account for that source of variance.

- A sample is a single flower from a given plant that was sampled on a given day. For each sample, we have scent measurements, and we have morphometric measurements.

  + *Issue*: A number of the morphological measurements are highly correlated with each other. This could be fine for the purposes of ordination, but less fine for other kinds of testing.

  + *Issue*: Sometimes we are missing some of the morphological measurements. Need to figure out how ordination methods deal with missing data.

## Questions

- Is constrained vs. non-constrained ordination more appropriate?

- What are the variables that we are analyzing? Morphology, total scent, emission rates.

- It seems like the overall premise is to test if variation in floral traits is A. related to variation in pollinators, B. clinal, or C. neither.

## Starting points

- Look at correlation matrices for all variables for each population

- Do ordinations using percents and also using toluene-equivalents, and also scent plus morphology

  + Try out different forms of ordination

- Think about how to visualize clinal patterns--add in column for lat/long?

## Data

From the `Test script` file, we have the following objects:

- `Percents_wide`: Scent data as percents, with all metadata
- `ER_flowers`: Emission rates per flower
- `ER_d_mass`: Emission rates per g dry mass
- `ER_f_mass`: Emission rates per g fresh mass
- `file3`: Morphology data of all samples. Can use `full_join` to combine with desired scent dataset

We can use these to make more objects:

```{r}
library(reshape2)
Arizona_per <- Percents_wide %>% 
  filter(Population=="Arizona" & Comp.2methylbutyronitrile!="NaN") %>% select(starts_with("Comp.")) 


Zion_morph <- file3 %>%  filter(Population=="Zion") %>% select(starts_with("M.")) %>% select(-M.Leaf_Number, -M.Leaf_Length) %>% drop_na() %>% mutate_all(.,as.numeric)


cormat <- round(cor(Zion_morph),2)
head(cormat)


melted_cormat <- melt(cormat)

ggplot(data = melted_cormat, aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile()+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
  cormat <- reorder_cormat(cormat)
   get_upper_tri <- function(cormat){
    cormat[lower.tri(cormat)]<- NA
    return(cormat)
  }
  
upper_tri <- get_upper_tri(cormat)
# Melt the correlation matrix
melted_cormat <- melt(upper_tri, na.rm = TRUE)
# Create a ggheatmap
ggheatmap <- ggplot(melted_cormat, aes(Var2, Var1, fill = value))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
   midpoint = 0, limit = c(-1,1), space = "Lab", 
    name="Pearson\nCorrelation") +
  theme_minimal()+ # minimal theme
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 12, hjust = 1))+
 coord_fixed()
# Print the heatmap
print(ggheatmap)
```


Now for some ordinations
```{r}
library(vegan)
library(ape)
library(dplyr)

##NMDS, based on percentages

Percents_ord <- Percents_wide %>% 
  filter(Comp.2methylbutyronitrile!="NaN") %>% select(starts_with("Comp."))

Percents_names <- Percents_wide %>% 
  filter(Comp.2methylbutyronitrile!="NaN") 

PercentsMDS<-metaMDS(Percents_ord, distance="bray", trymax = 35)

NMDS1 <- PercentsMDS$points[,1] ##also found using scores(birdMDS)
NMDS2 <- PercentsMDS$points[,2]
Percents.plot<-cbind(Percents_names, NMDS1, NMDS2)

p <- ggplot(Percents.plot, aes(NMDS1, NMDS2, color=Population))+
  geom_point(position=position_jitter(.1), shape=3) +
  stat_ellipse(type='t', size=1)+
  theme_minimal()

##NMDS, based on toluene equivalents per fresh mass

Tol_ord <- ER_f_mass %>% 
  select(starts_with("Comp."), Population) %>% filter_if(is.numeric, any_vars(. != 0)) %>% select(starts_with("Comp.")) %>% select(-Comp.Total)
  

Tol_names <- ER_f_mass %>% 
  select(starts_with("Comp."), Population) %>% filter_if(is.numeric, any_vars(. != 0))%>% select(-Comp.Total)

TolMDS<-metaMDS(Tol_ord, distance="bray", trymax = 35)

NMDS1 <- TolMDS$points[,1] ##also found using scores(birdMDS)
NMDS2 <- TolMDS$points[,2]
Tol.plot<-cbind(Tol_names, NMDS1, NMDS2)

p <- ggplot(Tol.plot, aes(NMDS1, NMDS2, color=Population))+
  geom_point(position=position_jitter(.1), shape=3) +
  stat_ellipse(type='t', size=1)+
  theme_minimal()


##Trying capscale:


Percents_ord2 <- Percents_wide %>% 
  filter(Comp.2methylbutyronitrile!="NaN"&Type=="Yes") %>% select(starts_with("Comp."))

Percents_names2 <- Percents_wide %>% 
  filter(Comp.2methylbutyronitrile!="NaN"&Type=="Yes") 

scents.cap <-capscale(Tol_ord ~ Population, Tol_names, dist="bray") 
scents.cap
summary(scents.cap)


scores<-as.data.frame(scores(scents.cap, display="sites"))


Percent_names_scores<-cbind(Percents_ord, scores)

cors <- as.data.frame(sapply(1:40,function(x) cor.test(Percent_names_scores[,x],Percent_names_scores$CAP1)))

cors2 <- as.data.frame(sapply(1:40,function(x) cor.test(Percent_names_scores[,x],Percent_names_scores$CAP2)))
pvals<-sapply(1:40,function(x) cors[,x]$p.value)
pvals2<-sapply(1:40,function(x) cors2[,x]$p.value)
pvals.a<-p.adjust(pvals, method="BH")
pvals.a2<-p.adjust(pvals2, method="BH")


co1<-sapply(1:40,function(x) cors[,x]$estimate)
co2<-sapply(1:40,function(x) cors2[,x]$estimate)


compounds<-colnames(Percents_ord)

c.table<-as.data.frame(cbind(compounds,cor1=co1,cap1=pvals.a,cor2=co2, cap2=pvals.a2))
c.table$cap1<-as.numeric(as.character(c.table$cap1))
c.table$cap2<-as.numeric(as.character(c.table$cap2))
c.table$sig1<-rep("No", times=dim(c.table)[1])
c.table$sig2<-rep("No", times=dim(c.table)[1])
c.table$sig1<-ifelse(c.table$cap1 < 0.01, "Yes", c.table$sig1)
c.table$sig2<-ifelse(c.table$cap2 < 0.01, "Yes", c.table$sig2)



#plot(scents.cap, type="points", axis.bp=TRUE)


colors<-c("firebrick1", "dodgerblue1", "cadetblue1", "goldenrod1","pink")


pl<-plot(scents.cap, type="n", scaling="sites", correlation=TRUE)
with(Tol_names, points(pl, "site",pch=c(21,22,23,24,25)[as.factor(Tol_names$Population)], bg= colors[as.factor(Tol_names$Population)],cex=1 ))
text(pl, "sp", scaling=1, arrow=TRUE, length=0.05, col=4, cex=0.6, xpd=TRUE)

```

Ordination of morphology

```{r}
morph_data<-file3 %>% select(starts_with("M.")) %>% select(-"M.Leaf_Number", -"M.Leaf_Length") %>% drop_na()

morph <- file3 %>% select(starts_with("M."), Population, Sample_ID) %>% select(-"M.Leaf_Number", -"M.Leaf_Length") %>% drop_na() 

morph_MDS<-metaMDS(morph_data, distance="bray", trymax = 35)

NMDS1 <- morph_MDS$points[,1] 
NMDS2 <- morph_MDS$points[,2]
pplot<-cbind(morph, NMDS1, NMDS2)

p <- ggplot(pplot, aes(NMDS1, NMDS2, color=Population))+
  geom_point(position=position_jitter(.1), shape=3) +
  stat_ellipse(type='t', size=1)+
  theme_minimal()

scents.cap <-capscale(morph_data ~ Population, morph, dist="bray") 
scents.cap
summary(scents.cap)

scores<-as.data.frame(scores(scents.cap, display="sites"))

morph_scores<-cbind(morph, scores)

cors <- as.data.frame(sapply(1:9,function(x) cor.test(morph_scores[,x],morph_scores$CAP1)))

cors2 <- as.data.frame(sapply(1:9,function(x) cor.test(morph_scores[,x],morph_scores$CAP2)))
pvals<-sapply(1:9,function(x) cors[,x]$p.value)
pvals2<-sapply(1:9,function(x) cors2[,x]$p.value)
pvals.a<-p.adjust(pvals, method="BH")
pvals.a2<-p.adjust(pvals2, method="BH")


co1<-sapply(1:9,function(x) cors[,x]$estimate)
co2<-sapply(1:9,function(x) cors2[,x]$estimate)


variables<-colnames(morph_data)

c.table<-as.data.frame(cbind(variables,cor1=co1,cap1=pvals.a,cor2=co2, cap2=pvals.a2))
c.table$cap1<-as.numeric(as.character(c.table$cap1))
c.table$cap2<-as.numeric(as.character(c.table$cap2))
c.table$sig1<-rep("No", times=dim(c.table)[1])
c.table$sig2<-rep("No", times=dim(c.table)[1])
c.table$sig1<-ifelse(c.table$cap1 < 0.01, "Yes", c.table$sig1)
c.table$sig2<-ifelse(c.table$cap2 < 0.01, "Yes", c.table$sig2)


plot(scents.cap, type="points", axis.bp=TRUE)


colors<-c("firebrick1", "dodgerblue1", "cadetblue1", "goldenrod1","pink")

pl<-plot(scents.cap, type="n")
with(morph, points(pl, "site",pch=c(21,22,23,24,25)[as.factor(morph$Population)], bg= colors[as.factor(morph$Population)],cex=1 ))
text(pl, "sp", scaling=1, arrow=TRUE, length=0.05, col=4, cex=0.6, xpd=TRUE)



```



Let's do some more basic things to try to diagnose what is going on
```{r}
Percents_names %>% group_by(Population) %>% summarise(N.samples=length(Population))

Compound_abund<-Percents_names %>% group_by(Population) %>% summarise_at(vars(starts_with("Comp.")), list(~ sum(as.logical(.))))

Compound_abund_flip <- Compound_abund %>% pivot_longer(cols=starts_with("Comp."),names_to="Compound") %>% 
  pivot_wider(names_from=Population, values_from = value) %>% 
  mutate(Arizona.per = round(Arizona/72, 2)*100, Idaho.per = round(Idaho/13,2)*100, Inyo.per = round(Inyo/25, 2)*100, Logan.per = round(Logan/45,2)*100, Zion.per = round(Zion/13,2)*100)

write.csv(Compound_abund_flip, "Compound_frequencies.csv")


  


P_A<-Percents_names %>% select(starts_with("Comp."))
P_A[P_A>0]<-1

P_A_totals <- P_A %>%  mutate(Total=rowSums(.)) %>% cbind(., Population=Percents_names$Population, Pop_Plant=Percents_names$Pop_Plant) 


totals.model<-lmer(Total~Population+(1|Pop_Plant), data=P_A_totals)



P_A_totals_pl <- P_A_totals %>% 
  group_by(Population, Pop_Plant) %>% 
  summarise(Mean.N = mean(Total))

P_A_totals_pop <- P_A %>%  mutate(Total=rowSums(.)) %>% cbind(., Population=Percents_names$Population, Pop_Plant=Percents_names$Pop_Plant) %>% 
  group_by(Population) %>% 
  summarise(Mean.N = mean(Total))

P_A_totals_pop2 <- P_A_totals %>%  
  group_by(Population) %>% 
  summarise(Mean.N = mean(Mean.N))

P_A_MDS<-metaMDS(P_A, distance="bray", trymax = 35)

NMDS1 <- P_A_MDS$points[,1] 
NMDS2 <- P_A_MDS$points[,2]
pplot<-cbind(Percents_names, NMDS1, NMDS2)

p <- ggplot(pplot, aes(NMDS1, NMDS2, color=Population))+
  geom_point(position=position_jitter(.1), shape=3) +
  stat_ellipse(type='t', size=1)+
  theme_minimal()

```

Let's look at some univariate analyses for fun:

```{r}
library(lme4)
library(lmerTest)
library(emmeans)

lin.model<-lmer(Comp.linalool~Population+(1|Pop_Plant), data=ER_f_mass)

total.model<-lmer(sqrt(Comp.Total)~Population+(1|Pop_Plant), data=ER_f_mass)

hist(resid(total.model))
plot(predict(total.model),resid(total.model)) 

summary(total.model)
anova(total.model)

emmeans(total.model, pairwise~Population, type="response")

ggplot(aes(x=Population, y=Total), data=P_A_totals)+geom_boxplot()
```

